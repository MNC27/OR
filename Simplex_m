#include <iostream>
#include <vector>
#include <iomanip>
#include <limits>
#include <cmath>

using namespace std;

double absval(double x) {
    return (x < 0) ? -x : x;
}

// Matrix-vector multiplication: res = A * B
void matvec(vector<double> &res, const vector<vector<double>> &A, const vector<double> &B, int m) {
    for (int i = 0; i < m; ++i) {
        res[i] = 0;
        for (int j = 0; j < m; ++j)
            res[i] += A[i][j] * B[j];
    }
}

// Matrix-matrix multiplication: res = A * B
void matmat(vector<vector<double>> &res, const vector<vector<double>> &A, const vector<vector<double>> &B, int m, int n) {
    for (int i = 0; i < m; ++i)
        for (int j = 0; j < n; ++j) {
            res[i][j] = 0;
            for (int k = 0; k < m; ++k)
                res[i][j] += A[i][k] * B[k][j];
        }
}

int main() {
    int m, n;
    const double eps = 1e-9;
    const double inf = numeric_limits<double>::infinity();
    const int max_iter = 1000;

    cout << "Enter number of constraints: ";
    cin >> m;
    cout << "Enter number of variables: ";
    cin >> n;

    vector<vector<double>> a(m, vector<double>(n));
    vector<double> b(m), c(n);
    vector<vector<double>> binv(m, vector<double>(m));
    vector<double> soln(m), cb(m), zj(n), zjcj(n);
    vector<vector<double>> binva(m, vector<double>(n));
    vector<int> ib(m);

    cout << "Enter the coefficient matrix:\n";
    for (int i = 0; i < m; ++i)
        for (int j = 0; j < n; ++j)
            cin >> a[i][j];

    cout << "Enter RHS vector:\n";
    for (int i = 0; i < m; ++i)
        cin >> b[i];

    cout << "Enter cost vector:\n";
    for (int i = 0; i < n; ++i)
        cin >> c[i];

    cout << "Enter index set of basic variables (1-based indexing):\n";
    for (int i = 0; i < m; ++i) {
        cin >> ib[i];
        ib[i]--; // convert to 0-based
    }

    // Initialize binv as identity matrix
    for (int i = 0; i < m; ++i)
        for (int j = 0; j < m; ++j)
            binv[i][j] = (i == j) ? 1 : 0;

    int iter = 0;
    while (true) {
        if (++iter > max_iter) {
            cout << "Maximum iterations reached. Stopping.\n";
            break;
        }

        // Compute current solution: xB = B^-1 * b
        matvec(soln, binv, b, m);

        // Compute B^-1 * A
        matmat(binva, binv, a, m, n);

        // Get cost of basic variables
        for (int i = 0; i < m; ++i)
            cb[i] = c[ib[i]];

        // Compute zj
        for (int j = 0; j < n; ++j) {
            zj[j] = 0;
            for (int i = 0; i < m; ++i)
                zj[j] += cb[i] * binva[i][j];
        }

        // Compute zj - cj
        for (int j = 0; j < n; ++j) {
            zjcj[j] = zj[j] - c[j];
            if (absval(zjcj[j]) < eps) zjcj[j] = 0;
        }

        // Choose entering variable (most negative reduced cost, non-basic only)
        double amin = 0.0;
        int evn = -1;
        for (int j = 0; j < n; ++j) {
            bool isBasic = false;
            for (int i = 0; i < m; ++i)
                if (ib[i] == j) { isBasic = true; break; }
            if (isBasic) continue;

            if (zjcj[j] < amin - eps) {
                amin = zjcj[j];
                evn = j;
            }
        }

        // If no entering variable found, optimal
        if (evn == -1) {
            cout << "Optimal solution found.\n";
            double z = 0;
            for (int i = 0; i < m; ++i)
                z += cb[i] * soln[i];
            cout << "Optimal value: " << z << endl;

            cout << "Variable values:\n";
            for (int j = 0; j < n; ++j) {
                bool isBasic = false;
                for (int i = 0; i < m; ++i) {
                    if (ib[i] == j) {
                        cout << "x" << j + 1 << " = " << soln[i] << endl;
                        isBasic = true;
                        break;
                    }
                }
                if (!isBasic)
                    cout << "x" << j + 1 << " = 0\n";
            }
            break;
        }

        // Choose leaving variable
        int pp = -1;
        double ratio = inf;
        for (int i = 0; i < m; ++i) {
            if (binva[i][evn] > eps) {
                double r = soln[i] / binva[i][evn];
                if (r + eps < ratio) {
                    ratio = r;
                    pp = i;
                }
            }
        }

        if (pp == -1) {
            cout << "Unbounded solution exists.\n";
            break;
        }

        // Pivot operation: Update B^-1
        double pivot = binva[pp][evn];
        if (absval(pivot) < eps) {
            cout << "Pivot too small â€” stopping.\n";
            break;
        }

        for (int j = 0; j < m; ++j)
            binv[pp][j] /= pivot;

        for (int i = 0; i < m; ++i) {
            if (i == pp) continue;
            double factor = binva[i][evn];
            for (int j = 0; j < m; ++j)
                binv[i][j] -= factor * binv[pp][j];
        }

        ib[pp] = evn;
    }

    return 0;
}
