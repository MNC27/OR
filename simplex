#include <iostream>
#include <vector>
#include <iomanip>
#include <limits>
#include <cmath>

using namespace std;

double absval(double x) {
    return (x < 0) ? -x : x;
}

// Matrix-vector multiplication: res = A * B
void matvec(vector<double> &res, const vector<vector<double>> &A, const vector<double> &B, int m) {
    for (int i = 0; i < m; ++i) {
        res[i] = 0;
        for (int j = 0; j < m; ++j)
            res[i] += A[i][j] * B[j];
    }
}

// Matrix-matrix multiplication: res = A * B
void matmat(vector<vector<double>> &res, const vector<vector<double>> &A, const vector<vector<double>> &B, int m, int n) {
    for (int i = 0; i < m; ++i)
        for (int j = 0; j < n; ++j) {
            res[i][j] = 0;
            for (int k = 0; k < m; ++k)
                res[i][j] += A[i][k] * B[k][j];
        }
}

int main() {
    int m, n;
    cout << "Enter number of constraints: ";
    cin >> m;
    cout << "Enter number of variables: ";
    cin >> n;

    vector<vector<double>> a(m, vector<double>(n));
    vector<double> b(m), c(n);
    vector<vector<double>> binv(m, vector<double>(m));
    vector<double> soln(m), cb(m), zj(n), zjcj(n);
    vector<vector<double>> binva(m, vector<double>(n));
    vector<int> ib(m);

    cout << "Enter the coefficient matrix:\n";
    for (int i = 0; i < m; ++i)
        for (int j = 0; j < n; ++j)
            cin >> a[i][j];

    cout << "Enter RHS vector:\n";
    for (int i = 0; i < m; ++i)
        cin >> b[i];

    cout << "Enter cost vector:\n";
    for (int i = 0; i < n; ++i)
        cin >> c[i];

    cout << "Enter index set of basic variables:\n";
    for (int i = 0; i < m; ++i)
        cin >> ib[i];

    // Initialize binv as identity matrix
    for (int i = 0; i < m; ++i)
        for (int j = 0; j < m; ++j)
            binv[i][j] = (i == j) ? 1 : 0;

    while (true) {
        // Compute current solution: xB = B^-1 * b
        matvec(soln, binv, b, m);

        // Compute B^-1 * A
        matmat(binva, binv, a, m, n);

        // Get cost of basic variables
        for (int i = 0; i < m; ++i)
            cb[i] = c[ib[i]];

        // Compute zj
        for (int j = 0; j < n; ++j) {
            zj[j] = 0;
            for (int i = 0; i < m; ++i)
                zj[j] += cb[i] * binva[i][j];
        }

        // Compute zj - cj
        for (int j = 0; j < n; ++j) {
            zjcj[j] = zj[j] - c[j];
            if (absval(zjcj[j]) < 1e-6) zjcj[j] = 0;
        }

        // Choose entering variable
        double amin = 1e9;
        int evn = -1;
        for (int j = 0; j < n; ++j) {
            if (zjcj[j] < amin) {
                amin = zjcj[j];
                evn = j;
            }
        }

        // If all reduced costs are â‰¥ 0, optimal
        if (amin >= 0) {
            cout << "Optimal solution found.\n";
            double z = 0;
            for (int i = 0; i < m; ++i)
                z += cb[i] * soln[i];
            cout << "Optimal value: " << z << endl;

            cout << "Variable values:\n";
            for (int j = 0; j < n; ++j) {
                bool isBasic = false;
                for (int i = 0; i < m; ++i) {
                    if (ib[i] == j) {
                        cout << "x" << j << " = " << soln[i] << endl;
                        isBasic = true;
                        break;
                    }
                }
                if (!isBasic)
                    cout << "x" << j << " = 0\n";
            }
            break;
        }

        // Choose leaving variable
        int pp = -1;
        double ratio = 1e9;
        for (int i = 0; i < m; ++i) {
            if (binva[i][evn] > 0) {
                double r = soln[i] / binva[i][evn];
                if (r < ratio) {
                    ratio = r;
                    pp = i;
                }
            }
        }

        if (pp == -1) {
            cout << "Unbounded solution exists.\n";
            break;
        }

        // Pivot operation: Update B^-1
        double pivot = binva[pp][evn];
        for (int j = 0; j < m; ++j)
            binv[pp][j] /= pivot;

        for (int i = 0; i < m; ++i) {
            if (i == pp) continue;
            double factor = binva[i][evn];
            for (int j = 0; j < m; ++j)
                binv[i][j] -= factor * binv[pp][j];
        }

        ib[pp] = evn;
    }

    return 0;
}
