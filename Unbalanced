#include <iostream>
#include <vector>
#include <limits>
#include <algorithm>
#include <numeric>
#include <queue>
using namespace std;

// Read 1D vector
void read(vector<int>& arr, int n, string name) {
    arr.resize(n);
    for (int i = 0; i < n; i++) {
        cout << "Enter " << name << " " << i + 1 << ": ";
        cin >> arr[i];
    }
}

// Read cost matrix
void readMatrix(vector<vector<int>>& cost, int m, int n) {
    cost.resize(m, vector<int>(n));
    cout << "Enter the cost matrix:\n";
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++)
            cin >> cost[i][j];
    }
}

// Calculate penalty for a row/column
int calcPenalty(const vector<int>& costs, const vector<bool>& done) {
    vector<int> avail;
    for (int i = 0; i < costs.size(); i++)
        if (!done[i]) avail.push_back(costs[i]);
    if (avail.size() < 2) return 0;
    sort(avail.begin(), avail.end());
    return avail[1] - avail[0];
}

// Find initial BFS using VAM
vector<vector<int>> VAM(vector<vector<int>> cost, vector<int> supply, vector<int> demand) {
    int m = supply.size();
    int n = demand.size();
    vector<vector<int>> alloc(m, vector<int>(n, 0));
    vector<bool> rowDone(m, false), colDone(n, false);

    while (true) {
        // Step 1: Calculate penalties
        vector<int> rowPenalty(m, -1), colPenalty(n, -1);
        for (int i = 0; i < m; i++)
            if (!rowDone[i]) rowPenalty[i] = calcPenalty(cost[i], colDone);

        for (int j = 0; j < n; j++) {
            if (!colDone[j]) {
                vector<int> temp;
                for (int i = 0; i < m; i++)
                    if (!rowDone[i]) temp.push_back(cost[i][j]);
                if (temp.size() < 2) colPenalty[j] = 0;
                else {
                    sort(temp.begin(), temp.end());
                    colPenalty[j] = temp[1] - temp[0];
                }
            }
        }

        // Step 2: Find largest penalty
        int maxRowPen = *max_element(rowPenalty.begin(), rowPenalty.end());
        int maxColPen = *max_element(colPenalty.begin(), colPenalty.end());

        bool chooseRow = (maxRowPen >= maxColPen);
        int r = -1, c = -1;

        if (chooseRow) {
            r = max_element(rowPenalty.begin(), rowPenalty.end()) - rowPenalty.begin();
            int minCost = INT_MAX;
            for (int j = 0; j < n; j++)
                if (!colDone[j] && cost[r][j] < minCost) {
                    minCost = cost[r][j];
                    c = j;
                }
        } else {
            c = max_element(colPenalty.begin(), colPenalty.end()) - colPenalty.begin();
            int minCost = INT_MAX;
            for (int i = 0; i < m; i++)
                if (!rowDone[i] && cost[i][c] < minCost) {
                    minCost = cost[i][c];
                    r = i;
                }
        }

        // Step 3: Allocate
        int allocation = min(supply[r], demand[c]);
        alloc[r][c] = allocation;
        supply[r] -= allocation;
        demand[c] -= allocation;

        if (supply[r] == 0) rowDone[r] = true;
        if (demand[c] == 0) colDone[c] = true;

        bool allRowsDone = all_of(rowDone.begin(), rowDone.end(), [](bool x){return x;});
        bool allColsDone = all_of(colDone.begin(), colDone.end(), [](bool x){return x;});
        if (allRowsDone || allColsDone) break;
    }

    return alloc;
}

// Calculate total cost
long long calcCost(const vector<vector<int>>& alloc, const vector<vector<int>>& cost) {
    long long total = 0;
    for (int i = 0; i < alloc.size(); i++)
        for (int j = 0; j < alloc[0].size(); j++)
            total += (long long)alloc[i][j] * cost[i][j];
    return total;
}

// Check optimality using MODI (u-v) method
bool MODI(vector<vector<int>>& alloc, vector<vector<int>>& cost, long long& totalCost) {
    int m = alloc.size(), n = alloc[0].size();
    vector<int> u(m, INT_MAX), v(n, INT_MAX);
    u[0] = 0;

    // Step 1: Calculate u & v
    bool changed = true;
    while (changed) {
        changed = false;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (alloc[i][j] > 0) {
                    if (u[i] != INT_MAX && v[j] == INT_MAX) {
                        v[j] = cost[i][j] - u[i];
                        changed = true;
                    } else if (v[j] != INT_MAX && u[i] == INT_MAX) {
                        u[i] = cost[i][j] - v[j];
                        changed = true;
                    }
                }
            }
        }
    }

    // Step 2: Check for optimality (calculate opportunity cost)
    int enter_i = -1, enter_j = -1;
    int maxPos = 0;
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (alloc[i][j] == 0) {
                int d = u[i] + v[j] - cost[i][j];
                if (d > maxPos) {
                    maxPos = d;
                    enter_i = i;
                    enter_j = j;
                }
            }
        }
    }

    // Step 3: If no positive opportunity cost, optimum reached
    if (maxPos <= 0) return true;

    cout << "\nImproving solution (cell entering basis: " << enter_i+1 << "," << enter_j+1 << ")\n";

    // Step 4: Build closed loop
    vector<pair<int,int>> cells;
    for (int i = 0; i < m; i++)
        for (int j = 0; j < n; j++)
            if (alloc[i][j] > 0)
                cells.push_back({i, j});
    cells.push_back({enter_i, enter_j});

    // Simple loop correction
    vector<pair<int,int>> loop;
    loop.push_back({enter_i, enter_j});
    int curRow = enter_i, curCol = enter_j;
    for (auto c : cells) {
        if (c.first == curRow && c.second != curCol) {
            loop.push_back(c);
            curCol = c.second;
        } else if (c.second == curCol && c.first != curRow) {
            loop.push_back(c);
            curRow = c.first;
        }
    }

    // Step 5: Find minimum theta
    int theta = INT_MAX;
    int leave_i = -1, leave_j = -1;
    for (int k = 1; k < loop.size(); k += 2) {
        int i = loop[k].first, j = loop[k].second;
        if (alloc[i][j] < theta) {
            theta = alloc[i][j];
            leave_i = i;
            leave_j = j;
        }
    }

    // Step 6: Adjust allocations
    for (int k = 0; k < loop.size(); k++) {
        int sign = (k % 2 == 0) ? 1 : -1;
        int i = loop[k].first, j = loop[k].second;
        alloc[i][j] += sign * theta;
    }

    alloc[leave_i][leave_j] = 0;
    totalCost = calcCost(alloc, cost);
    return false;
}

int main() {
    int m, n;
    cout << "Enter number of sources: ";
    cin >> m;
    cout << "Enter number of destinations: ";
    cin >> n;

    vector<int> supply(m), demand(n);
    read(supply, m, "supply");
    read(demand, n, "demand");

    vector<vector<int>> cost;
    readMatrix(cost, m, n);

    int totalS = accumulate(supply.begin(), supply.end(), 0);
    int totalD = accumulate(demand.begin(), demand.end(), 0);

    // Balance the problem
    if (totalS > totalD) {
        cout << "\nUnbalanced! Adding dummy destination with demand " << totalS - totalD << endl;
        n++;
        for (int i = 0; i < m; i++) cost[i].push_back(0);
        demand.push_back(totalS - totalD);
    } else if (totalD > totalS) {
        cout << "\nUnbalanced! Adding dummy source with supply " << totalD - totalS << endl;
        m++;
        vector<int> dummy(n, 0);
        cost.push_back(dummy);
        supply.push_back(totalD - totalS);
    }

    // Step 1: Find IBFS using VAM
    vector<vector<int>> alloc = VAM(cost, supply, demand);

    cout << "\nInitial Basic Feasible Solution (VAM):\n";
    for (auto& row : alloc) {
        for (int x : row) cout << x << "\t";
        cout << "\n";
    }

    long long totalCost = calcCost(alloc, cost);
    cout << "\nInitial Cost = " << totalCost << "\n";

    // Step 2: Optimize using MODI
    while (!MODI(alloc, cost, totalCost)) {
        cout << "Updated Cost = " << totalCost << "\n";
    }

    cout << "\n--- OPTIMAL SOLUTION ---\n";
    for (int i = 0; i < alloc.size(); i++) {
        for (int j = 0; j < alloc[0].size(); j++) {
            if (alloc[i][j] > 0)
                cout << "From Source " << i+1 << " to Destination " << j+1 << ": " << alloc[i][j] << "\n";
        }
    }

    cout << "\nFinal Minimum Cost = " << totalCost << "\n";
    return 0;
}
