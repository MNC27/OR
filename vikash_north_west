#include <iostream>
#include <vector>
#include <numeric> // Required for numeric_limits
#include <queue>   // Required for queue in u,v calculation
#include <utility> // Required for pair
using namespace std;
// Function to read a 1D vector (supply/demand)
void read(vector<int>& arr, int n) {
    arr.resize(n);
    for (int i = 0; i < n; i++)
        cin >> arr[i];
}
// Function to read a 2D vector (cost matrix)
void read(vector<vector<int>>& arr, int n, int m) {
    arr.resize(n, vector<int>(m));
    for (int i = 0; i < n; i++) {
        cout << "Enter the elements of row " << i + 1 << ": ";
        for (int j = 0; j < m; j++)
            cin >> arr[i][j];
    }
}
// Function to print a 1D vector
void print(const vector<int>& arr) {
    for (int x : arr)
        cout << x << " ";
    cout << endl;
}
// Function to print a 2D vector
void print(const vector<vector<int>>& arr) {
    for (const auto& x : arr) {
        for (int y : x)
            cout << y << " ";
        cout << "\n";
    }
}
int main() {
    int m, n;
    cout << "Enter the number of sources and destinations respectively: ";
    cin >> m >> n;
    vector<int> a(m), b(n);
    cout << "Enter the supply at each source: ";
    read(a, m);
    cout << "Enter the demand at each destination: ";
    read(b, n);
    vector<vector<int>> cost(m, vector<int>(n));
    cout << "Enter the cost matrix:\n";
    read(cost, m, n);
    // Make copies of supply and demand for calculations
    vector<int> supply = a;
    vector<int> demand = b;
    long long optimum_cost = 0;
    int count = 0;
    vector<int> row_ind(m + n - 1), col_ind(m + n - 1), soln(m + n - 1);
    vector<int> u(m), v(n);
    // --- North West Corner Rule for Initial Basic Feasible Solution ---
    int i = 0, j = 0;
    while (count < m + n - 1) {
        row_ind[count] = i;
        col_ind[count] = j;
        if (supply[i] < demand[j]) {
            soln[count] = supply[i];
            demand[j] -= supply[i];
            supply[i] = 0;
            i++;
        } else {
            soln[count] = demand[j];
            supply[i] -= demand[j];
            demand[j] = 0;
            j++;
        }
        count++;
    }
    // Printing the initial basic feasible solution
    cout << "\nThe initial basic feasible solution is:\n";
    for (int k = 0; k < count; k++) {
        cout << "From source " << row_ind[k] + 1 << " to destination " << col_ind[k] + 1 << " transport " << soln[k] << " units\n";
        optimum_cost += (long long)soln[k] * cost[row_ind[k]][col_ind[k]];
    }
    cout << "\nThe initial cost is: " << optimum_cost << "\n\n";
    //MODI (UV) Method for Optimal Solution
    while (true) {
        // 1. Calculate u_i and v_j for basic cells (where u_i + v_j = c_ij)
        const int UNVISITED = numeric_limits<int>::max();
        u.assign(m, UNVISITED);
        v.assign(n, UNVISITED);
        u[0] = 0; // Assume u_0 = 0
        queue<pair<char, int>> q;
        q.push({'r', 0});
        while (!q.empty()) {
            char type = q.front().first;
            int index = q.front().second;
            q.pop();
            if (type == 'r') {
                for (int k = 0; k < count; k++) {
                    if (row_ind[k] == index && v[col_ind[k]] == UNVISITED) {
                        v[col_ind[k]] = cost[index][col_ind[k]] - u[index];
                        q.push({'c', col_ind[k]});
                    }
                }
            } else {
                for (int k = 0; k < count; k++) {
                    if (col_ind[k] == index && u[row_ind[k]] == UNVISITED) {
                        u[row_ind[k]] = cost[row_ind[k]][index] - v[index];
                        q.push({'r', row_ind[k]});
                    }
                }
            }
        }
        // 2. Calculate opportunity cost (d_ij = u_i + v_j - c_ij) for non-basic cells
        int max_opportunity_cost = 0;
        int entering_r = -1, entering_c = -1;
        for (int r = 0; r < m; r++) {
            for (int c = 0; c < n; c++) {
                bool is_basic = false;
                for (int k = 0; k < count; k++) {
                    if (row_ind[k] == r && col_ind[k] == c) {
                        is_basic = true;
                        break;
                    }
                }
                if (!is_basic) {
                    int opportunity_cost = u[r] + v[c] - cost[r][c];
                    if (opportunity_cost > max_opportunity_cost) {
                        max_opportunity_cost = opportunity_cost;
                        entering_r = r;
                        entering_c = c;
                    }
                }
            }
        }
        // 3 Check for optimality
        if (max_opportunity_cost <= 0) {
            cout << "--- Optimality Reached ---" << endl;
            break; // Optimal solution found
        }
        // 4 Find the closed-path loop using the pruning method
        vector<pair<int, int>> candidates;
        for(int k=0; k<count; ++k) candidates.push_back({row_ind[k], col_ind[k]});
        candidates.push_back({entering_r, entering_c});
        vector<int> rowCount(m, 0), colCount(n, 0);
        for(const auto& cell : candidates) {
            rowCount[cell.first]++;
            colCount[cell.second]++;
        }
        bool removed;
        do {
            removed = false;
            for (auto it = candidates.begin(); it != candidates.end(); ) {
                if (rowCount[it->first] == 1 || colCount[it->second] == 1) {
                    rowCount[it->first]--;
                    colCount[it->second]--;
                    it = candidates.erase(it);
                    removed = true;
                } else {
                    ++it;
                }
            }
        } while (removed);

        vector<pair<int, int>> loop_path;
        loop_path.push_back({entering_r, entering_c});
        int current_r = entering_r, current_c = entering_c;

        while(loop_path.size() < candidates.size()){
            // Find next corner in row
            for(auto it = candidates.begin(); it != candidates.end(); ++it){
                if(it->first == current_r && it->second != current_c){
                    current_c = it->second;
                    loop_path.push_back(*it);
                    break;
                }
            }
            // Find next corner in column
            for(auto it = candidates.begin(); it != candidates.end(); ++it){
                if(it->second == current_c && it->first != current_r){
                    current_r = it->first;
                    loop_path.push_back(*it);
                    break;
                }
            }
        }

        // 5 Determine theta (amount to be transferred) and the leaving cell
        int theta = numeric_limits<int>::max();
        int leaving_r = -1, leaving_c = -1;
        for (int k = 1; k < loop_path.size(); k += 2) { // Subtract cells
            for (int l = 0; l < count; l++) {
                if (row_ind[l] == loop_path[k].first && col_ind[l] == loop_path[k].second) {
                    if (soln[l] < theta) {
                        theta = soln[l];
                        leaving_r = row_ind[l];
                        leaving_c = col_ind[l];
                    }
                    break;
                }
            }
        }
        // 6 Update allocations along the loop
        for (int k = 0; k < loop_path.size(); k++) {
            int r = loop_path[k].first;
            int c = loop_path[k].second;
            int sign = (k % 2 == 0) ? 1 : -1; // Alternate + and -
            int l_idx = -1;
            for (int l = 0; l < count; l++) {
                if (row_ind[l] == r && col_ind[l] == c) {
                    l_idx = l;
                    break;
                }
            }
            if (l_idx != -1) {
                soln[l_idx] += theta * sign;
            }
        }
        // 7 Update the basic variables: entering cell replaces leaving cell
        for (int k = 0; k < count; k++) {
            if (row_ind[k] == leaving_r && col_ind[k] == leaving_c) {
                row_ind[k] = entering_r;
                col_ind[k] = entering_c;
                soln[k] = theta;
                break;
            }
        }
        // Update total cost
        optimum_cost -= (long long)theta * max_opportunity_cost;
        cout << "Iteration update: New cost is " << optimum_cost << endl;
    }
    //Printing the final optimal solution
    cout << "The final optimal solution is:\n";
    for (int k = 0; k < count; k++) {
        if(soln[k] > 0) { // Only print meaningful allocations
            cout << "From source " << row_ind[k] + 1 << " to destination " << col_ind[k] + 1 << " transport " << soln[k] << " units\n";
        }
    }
    cout << "\nThe final optimum cost is: " << optimum_cost << "\n";
    return 0;
}//My Code
